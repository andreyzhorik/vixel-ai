<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NOT AI â€” GPTS</title>
<style>
  :root{
    --bg:#0a0f1c; --panel:#10182a; --accent:#3b82f6; --accent-soft:#1d4ed8;
    --muted:#94a3b8; --text:#e5eaf5; --radius:14px; --shadow:0 10px 30px rgba(0,0,0,.3);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, sans-serif;
  }
  *{box-sizing:border-box}
  body{margin:0;min-height:100vh;display:flex;align-items:center;justify-content:center;
    background:linear-gradient(180deg,var(--bg),#060b17);color:var(--text)}
  .app{width:95%;max-width:900px;height:90vh;background:var(--panel);border-radius:var(--radius);
    box-shadow:var(--shadow);display:flex;flex-direction:column;overflow:hidden;border:1px solid rgba(255,255,255,0.04)}
  header{display:flex;align-items:center;justify-content:space-between;padding:18px;border-bottom:1px solid rgba(255,255,255,0.04)}
  .brand{display:flex;gap:12px;align-items:center}
  .logo{width:44px;height:44px;border-radius:10px;background:linear-gradient(135deg,var(--accent),var(--accent-soft));
    display:flex;align-items:center;justify-content:center;font-weight:800;color:#fff}
  .title{font-weight:700;color:var(--accent)}
  .controls{display:flex;gap:10px;align-items:center}
  select{background:rgba(255,255,255,0.03);color:var(--text);border:1px solid rgba(255,255,255,0.06);
    padding:8px 10px;border-radius:10px;font-weight:600;cursor:pointer}
  .btn{background:var(--accent);border:none;color:#fff;padding:8px 12px;border-radius:10px;cursor:pointer;font-weight:700}
  .chat{flex:1;overflow:auto;padding:20px;display:flex;flex-direction:column;gap:12px}
  .msg{max-width:78%;padding:12px 16px;border-radius:12px;line-height:1.4;box-shadow:0 6px 18px rgba(0,0,0,0.3)}
  .msg.user{align-self:flex-end;background:linear-gradient(135deg,var(--accent-soft),var(--accent));color:#fff;border-bottom-right-radius:6px}
  .msg.assistant{align-self:flex-start;background:#111827;color:var(--text);border-bottom-left-radius:6px}
  .meta{font-size:12px;color:var(--muted);margin-top:6px}
  footer{display:flex;gap:10px;padding:14px;border-top:1px solid rgba(255,255,255,0.04);background:#0d1525}
  textarea{flex:1;min-height:56px;border-radius:10px;padding:12px;background:#0c1222;border:1px solid rgba(255,255,255,0.06);color:var(--text);resize:none}
  button.send{background:var(--accent);color:#fff;border:none;padding:12px 18px;border-radius:10px;font-weight:700;cursor:pointer}
  .small{font-size:12px;color:var(--muted)}
  .typing{width:48px;height:18px;border-radius:12px;background:#162037;display:flex;gap:6px;align-items:center;padding:6px}
  .dot{width:8px;height:8px;border-radius:50%;background:var(--muted);animation:blink 1s infinite}
  .dot:nth-child(2){animation-delay:.15s}.dot:nth-child(3){animation-delay:.3s}
  @keyframes blink{0%{opacity:.15}50%{opacity:1}100%{opacity:.15}}
  @media (max-width:640px){.app{height:100vh;border-radius:0}}
</style>
</head>
<body>
  <div class="app" role="application" aria-label="NOT AI chat UI">
    <header>
      <div class="brand">
        <div class="logo">N-A</div>
        <div>
          <div class="title">NOT AI</div>
          <div class="small">Local & Private Chat UI</div>
        </div>
      </div>

      <div class="controls">
        <label class="small" for="provider">Model</label>
        <select id="provider" title="Choose model">
          <!-- locked models have data-locked="true" -->
          <option value="gpt-4o-mini" data-locked="false">GPT-4o-mini (free and good thinking)</option>
          <option value="gpt-4o" data-locked="true">GPT-4o (locked and good for everything)</option>
          <option value="gpt-4.1-mini" data-locked="true">GPT-4.1-mini (locked and good for school)</option>
          <option value="gpt-3.5-turbo" data-locked="false">GPT-3.5-turbo (free and simple)</option>
        </select>
        <button class="btn" id="clearBtn" title="Clear chat">Clear</button>
      </div>
    </header>

    <main class="chat" id="chat" aria-live="polite"></main>

    <footer>
      <textarea id="prompt" placeholder="Type your message..." aria-label="Message input"></textarea>
      <button class="send" id="sendBtn">Send</button>
    </footer>
  </div>

<script>
(() => {
  /* ========== CONFIG ========== */
  // Set your two worker endpoints here:
  const PRIMARY_API = "https://plain-pine-b32a.mrviktor2426.workers.dev/"; // primary (main)
  const BACKUP_API  = "https://wispy-voice-741d.mrviktor2426.workers.dev";            // backup (replace this)

  /* ========== DOM ELEMENTS (expected) ========== */
  const providerSel = document.getElementById("provider");
  const chatEl = document.getElementById("chat");
  const promptEl = document.getElementById("prompt");
  const sendBtn = document.getElementById("sendBtn") || document.getElementById("send");
  const clearBtn = document.getElementById("clearBtn");

  if (!chatEl || !promptEl || !sendBtn) {
    console.error("Script requires elements with IDs: chat, prompt, sendBtn (or send).");
    return;
  }

  /* ========== Populate dropdown exactly as requested ========== */
  if (providerSel) {
    providerSel.innerHTML = `
      <option value="gpt-4.1-mini" data-locked="true">GPT-4.1-mini (locked)</option>
      <option value="gpt-4o" data-locked="true">GPT-4o (locked)</option>
      <option value="gpt-4o-mini" data-locked="false">GPT-4o-mini (free)</option>
      <option value="gpt-3.5-turbo" data-locked="false">GPT-3.5-turbo (free)</option>
    `;
  }

  /* ========== Helpers ========== */
  function nodeMsg(text, role = "assistant") {
    const div = document.createElement("div");
    div.className = "msg " + (role === "user" ? "user" : "assistant");
    div.textContent = text;
    return div;
  }
  function nodeMeta(text) {
    const m = document.createElement("div");
    m.className = "meta";
    m.textContent = text;
    return m;
  }
  function append(node) {
    chatEl.appendChild(node);
    chatEl.scrollTop = chatEl.scrollHeight;
  }
  function readableError(err) {
    if (!err) return "Unknown error";
    if (typeof err === "string") return err;
    try { return JSON.stringify(err, null, 2); } catch { return String(err); }
  }

  /* typing indicator */
  function showTyping() {
    if (document.getElementById("typingIndicator")) return;
    const wrap = document.createElement("div");
    wrap.className = "msg assistant";
    wrap.id = "typingIndicator";
    const t = document.createElement("div");
    t.className = "typing";
    t.innerHTML = '<span class="dot"></span><span class="dot"></span><span class="dot"></span>';
    wrap.appendChild(t);
    append(wrap);
  }
  function hideTyping() {
    const el = document.getElementById("typingIndicator");
    if (el) el.remove();
  }

  /* Basic GET verification helper: tries primary then backup if primary fails */
  async function verifyInvite(model, code) {
    // If model == 'gpt-4o-mini' backup supports it; otherwise backup likely won't verify locked models.
    const tryVerify = async (baseUrl) => {
      try {
        const u = new URL(baseUrl);
        u.searchParams.set("verify_code", code);
        u.searchParams.set("model", model);
        const res = await fetch(u.toString(), { method: "GET" });
        if (!res.ok) return false;
        const j = await res.json().catch(() => null);
        return !!(j && j.valid);
      } catch (e) {
        return false;
      }
    };

    // Primary first
    const primaryOk = await tryVerify(PRIMARY_API);
    if (primaryOk) return true;
    // fallback: try backup (only useful for gpt-4o-mini verification in your setup)
    const backupOk = await tryVerify(BACKUP_API);
    return backupOk;
  }

  /* Send request to a worker URL. Returns parsed JSON or { error: ... } */
  async function callWorker(baseUrl, provider, messages) {
    try {
      const res = await fetch(baseUrl, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ provider, messages }),
      });
      const txt = await res.text();
      try {
        return JSON.parse(txt);
      } catch {
        return { error: txt };
      }
    } catch (err) {
      return { error: { message: err.message || String(err) } };
    }
  }

  /* Primary send logic with fallback to backup. Backup supports only gpt-4o-mini, so we will switch model to that when using backup. */
  async function sendMessage(text) {
    const selectedModel = providerSel ? providerSel.value : "gpt-4o-mini";
    append(nodeMsg(text, "user"));

    // Show typing
    showTyping();

    // Try primary first with the selected model
    let resp = await callWorker(PRIMARY_API, selectedModel, [{ role: "user", content: text }]);

    // If primary responded with insufficient_quota error -> attempt fallback to gpt-4o-mini on primary first
    if (resp && resp.error && (resp.error.code === "insufficient_quota" || (typeof resp.error === "string" && resp.error.toLowerCase().includes("quota")))) {
      append(nodeMsg(`âš ï¸ Quota on ${selectedModel} â€” attempting fallback to gpt-4o-mini on primary...`, "assistant"));
      resp = await callWorker(PRIMARY_API, "gpt-4o-mini", [{ role: "user", content: text }]);
    }

    // If primary network error or any error and backup is configured -> try backup
    if ((resp && resp.error) || !resp) {
      // If the selected model is not gpt-4o-mini but backup only supports gpt-4o-mini,
      // inform user we will try the backup with gpt-4o-mini.
      const usingBackupModel = "gpt-4o-mini";
      append(nodeMsg("â„¹ï¸ Trying backup worker (" + BACKUP_API + ") with model " + usingBackupModel + "...", "assistant"));

      const respBackup = await callWorker(BACKUP_API, usingBackupModel, [{ role: "user", content: text }]);

      hideTyping();

      if (respBackup && !respBackup.error) {
        const replyBackup = respBackup.choices?.[0]?.message?.content ?? respBackup.response ?? "âš ï¸ No reply from backup";
        append(nodeMsg(replyBackup, "assistant"));
        return;
      } else {
        // Both failed: show readable errors (primary and backup)
        const primaryErr = resp && resp.error ? readableError(resp.error) : "No response from primary";
        const backupErr  = respBackup && respBackup.error ? readableError(respBackup.error) : "No response from backup";
        append(nodeMsg("âŒ Both primary and backup failed.\nPrimary error: " + primaryErr + "\nBackup error: " + backupErr, "assistant"));
        return;
      }
    }

    // Success from primary
    hideTyping();
    if (resp.error) {
      append(nodeMsg("âŒ Error: " + readableError(resp.error), "assistant"));
      return;
    }

    const reply = resp.choices?.[0]?.message?.content ?? resp.response ?? "âš ï¸ No reply";
    append(nodeMsg(reply, "assistant"));
  }

  /* When user changes model to a locked one, verify invite code */
  if (providerSel) {
    providerSel.addEventListener("change", async () => {
      const opt = providerSel.selectedOptions[0];
      if (!opt) return;
      const locked = opt.dataset.locked === "true";
      const model = opt.value;

      if (!locked) return;

      // If backup is only gpt-4o-mini, locked models other than gpt-4o-mini can't be unlocked on backup.
      const stored = localStorage.getItem("invite_for_" + model);
      if (stored) return; // already unlocked

      const code = prompt(`ðŸ”’ ${model} requires an invite code. Enter it now:`);
      if (!code) {
        alert("No code entered â€” switching to GPT-4o-mini.");
        providerSel.value = "gpt-4o-mini";
        return;
      }

      append(nodeMsg("Verifying inviteâ€¦", "assistant"));
      const ok = await verifyInvite(model, code);
      // remove last system message (verification)
      const sys = chatEl.querySelector(".msg.assistant:last-child");
      if (sys && sys.textContent === "Verifying inviteâ€¦") sys.remove();

      if (ok) {
        localStorage.setItem("invite_for_" + model, code);
        alert("âœ… Invite accepted for " + model);
      } else {
        alert("âŒ Invalid invite or unreachable verifier. Reverting to GPT-4o-mini.");
        providerSel.value = "gpt-4o-mini";
      }
    });
  }

  /* Wire UI: send button and Enter key */
  sendBtn.addEventListener("click", async () => {
    const t = promptEl.value.trim();
    if (!t) return;
    promptEl.value = "";
    await sendMessage(t);
  });
  promptEl.addEventListener("keydown", (e) => {
    if (e.key === "Enter" && !e.shiftKey) {
      e.preventDefault();
      sendBtn.click();
    }
  });
  if (clearBtn) clearBtn.addEventListener("click", () => chatEl.innerHTML = "");

  /* Startup hint */
  (function startHint() {
    const intro = nodeMsg("WELCOME TO NOT AI PUCK A MODEL AND TALK WITH REAL AI. âš  IF THERE IS AN ERROR WAIT LIKE 40 SEC AND IT WILL GO AWAY âš ");
    intro.appendChild(nodeMeta("Locked models require invite codes. Backup supports only gpt-4o-mini."));
    append(intro);
  })();

})();
</script>
</body>
</html>
